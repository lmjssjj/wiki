mysql 关系型数据库
net start/stop mysql
登录：mysql -h服务器地址 -u登录名 -P端口号 -p
或登录：mysql --host=服务器地址 --user=用户名 --port=端口 --password
退出：quit; 或 exit;
登录数据库系统后，需要使用“set names 编码名；”来设定当前连接数据库的“环境编码名”

备份和恢复在未登陆情况下
备份：mysqldump -h服务器地址 -u登录名 -P端口号 -p 数据库名>文件名
注意：需要管理员权限；
恢复：mysql -h服务器地址 -u登录名 -P端口号 -p 数据库名<文件名

单行注释： #注释内容
单行注释： -- 注释内容（注意，两个“--”之后有一个空格）
多行注释： /*注释内容*/

语句行：
一条语句也称为一条命令，通常用一个分号(;)结束；也可以通过"delimiter 新结束符" 命令来设定新的结束符。
语句的执行是以一条语句为单位进行，一次执行一条语句。

创建数据库
create database [if not exists] 数据库名 [character set=字符集] [collate=校对集];
character set:用来设定数据库中的字符数据所要使用的字符编码，一些固定的名字，常用有utf8，gbk，gb2312。 也可以写成charset。
collate：翻译为整序，整理，校对集，校对规则，排序规则——其实就是指字符以何种方式进行排序的设定，也是一些跟字符编码有关联的固定名字。比如“传”和“智”两个字，按拼音，就是“传”在前，但按笔顺，就是“智”在前。
数据库创建后的文件及存放位置：/data/数据库名/db.opt
其中的等号可以省略，但需有空格，比如：character set utf8 collate utf8_general_ci
查看字符集和排序规则：
show charset;
show collation;
create database lmjssjj charset utf8 collate utf8_general_ci;
create database lmjssjj charset gbk collate gbk_bin;
create database lmjssjj charset utf8;

修改数据库：所谓修改数据库就是修改数据库的选项值。
alter database 数据库名 character set=新字符集 collate=新校对集;

删除数据库
drop database [if exists] 数据库;
drop database if exists lmjssjj;

其他相关
进入（使用）某个数据库：
use lmjssjj;

显示所有数据库：
show databases;
显示某数据库的创建语句
show create database lmjssjj;

整数类型
tinyint(1), smallint(2), mediumint(3),int(4), bigint(8)。括号中表示该类型所占空间的长度（字节数）
整数类型所占空间（字节）：
int：占4个字节，即32位；
tinyint：占1个字节，即8位；	最多能存储256个数字，默认范围是-128~127
bigint：占8个字节，即64位；

整数类型通用设定形式： 类型名[(M)] [unsigned] [zerofill]。
其中M表示“显示长度”，其需与zerofill结合使用才有效，即不够该长度的会自动左侧补0，当然如果超出也不影响。
unsigned表示“无符号数”，表示其中的数值是“非负”数字
如果设置了zerofill，则自动也就表示同时具备了unsigned修饰
如果设置了zerofill但没有设定长度M，则其会默认将所有数的左边补0到该类型的最大位数
create table lmjssjj_tab(id int unsigned,age tinyint zerofill,price bigint(10) zerofill);
insert into lmjssjj_tab (id,age,price) values(12,12,12);
select * from lmjssjj_tab;
id  age    price
12  012  0000000012

小数类型
单精度浮点型：float，范围大约是-3.4E+38到-1.1E-38、0和1.1E-38到3.4E+38
双精度浮点型：double，范围大约是-1.7E+308到-2.2E-308、0和2.2E-308到 1.7E+308。 real是double的别名。
定点型：decimal，也可以写成：dec，numeric，fixed（当然后3者尽量不用）。
        decimal类型整数部分最长可以有65位，小数部分最长可以有30位。
        一般设置格式为：decimal(总位数，小数部分位数）
create table lmjssjj_tab(v1 float,v2 double,v3 decimal(10,3)/*表示总位数为10，小数位数为3*/);
insert into lmjssjj_tab(v1,v2,v3) values(123.456,123.456,123.456);
insert into lmjssjj_tab(v1,v2,v3) values(123.456789,123.456789,123.456789);
insert into lmjssjj_tab(v1,v2,v3) values(123456789,123456789,1234567);
select * from lmjssjj_tab;
v1            v2            v3
123.456     123.456       123.456
123.457     123.456789    123.457
123457000   123456789     1234567.000


字符串类型
定长字符串char：应设定字符个数，不足设定值，则右侧自动填满空格；最大255个字符。
变长字符串varchar：需设定字符个数，最大65532个字符，且不超过65532个字节（考虑字符集问题）。
                  但考虑到存储的字符编码不同，也会有进一步减少，比如，
                  如果存储中文gbk，则最多是65533/2个；
                  如果存储中文utf8，则最多是65533/3个；
                  实际还得考虑一行的其他字段所占的长度。
                  此类型的实际长度是存储内容决定，而设定值只是表示最多可存储的字符个数。
                  注意：这里的存储限制，其实都来源于一个表格的“一行”的数据存储最大容量限制：65535。

定长二进制字符串binary：类似char，应该设定长度值，只是按“二进制字节”保存存字符数据，最大255个字节，无编码问题
变长二进制字符串varbinary：类似varchar，需要设定长度值，只是按“二进制字节”存字符数据，最大65532个字节，无编码问题
文本列类型text：用于存储普通文本，不受行的最大长度的限制，同类还有：tinytext, mediuntext, longtext
二进制列类型blob：用于存储二进制字节内容，不受行的最大长度的限制，同类的还有：tinyblob, mediumblob, longblob
枚举类型enum： 类似单选项应用中的多个选项值，最大65535个选项值；使用形式：enum('value1', 'value2', ... )；
              存储数据的时候其实存的是一个对应的数字序号（从1开始）
set类型：类似多选项应用中的多个选项，最多64个选项，使用形式：set('value1', 'value2', ...)； 
         内部存储的也是数字（依次为1,2,4,8, ....），但可以是多个值，比如5就表示2个值（1，4），14就表示3个值（2，4，8）
create table lmjssjj_tab(postcost char(6),name varchar(10));
create table lmjssjj_tab(id int auto_increment primary key,sex enum("男"，"女"),fav set("篮球"，"足球","排球"));
insert into lmjssjj_tab(id,sex,fav) values(null,'男'，'篮球');
insert into lmjssjj_tab(id,sex,fav) values(null,1，1);
insert into lmjssjj_tab(id,sex,fav) values(null,'男'，'篮球,足球,排球');
insert into lmjssjj_tab(id,sex,fav) values(null,'男'，19);



时间日期类型
date类型： 支持的范围为'1000-01-01'到'9999-12-31'
time类型： 支持的范围是'-838:59:59'到'838:59:59'
datetime类型：支持的范围是'1000-01-01 00:00:00'到'9999-12-31 23:59:59'
timestamp类型：时间戳，就是表示“当前时刻”，类似函数now()获得的值，用于INSERT或UPDATE操作时自动获得当前时间
year类型： 四位字符串，范围为'1901'到'2155'；四位数字，范围为1901到2155；
            两位字符串，范围为'00'到'99'；两位整数，范围为1到99

其他（了解）：
位类型bit：使用形式：bit[(M)]，其中M是1-64的数字，表示使用多少位二进制数字来存储数据。
          插入形式为：b'value'，比如：b'101'
序列类型serial： 其实只是BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE的一个别名（同义词）
布尔类型bool：其实只是tinyint(1)的一个同义词，其值为0就表示false，否则表示true


创建表
基本形式：create table [if not exists] 表名 (字段列表 [，索引或约束列表]) [表选项列表]；
字段列表：多个字段的定义项，相互之间用逗号隔开；
字段定义形式：字段名 字段类型 [字段属性列表]

字段属性列表由多个字段属性构成，相互之间用空格隔开，可以包括如下一些：
primary key：设定为主键。主键的本质是表示“该表中该字段值可以唯一确定某行数据”，并具有2个隐含含义：唯一性，不为空。
unique [key]：设定为唯一（键），即表中所有行的的数据在该字段中的值不能有重复。
not null|null：设定该字段是否可空（可以放置空值null），默认不设置就是表示可为空。
auto_increment：设定自增长，表示一个整数类型的字段的值可以“自动递增取值”，设置后其必须同时设置为一个主键索引或唯一索引或普通索引。
                一个表只能有一个auto_increment属性的字段。
default 默认值：设定默认值，表示当插入新数据的时候如果该字段没有给值，就会自动使用该默认值。
comment '字段注释'：设置字段的注释文字，用单引号引起来。
create table lmjssjj_tab(id int auto_increment primary key,
                          user_name varchar(20) not null unique key,
                          password varchar(8) not null,
                          age tinyint default 18,
                          email varchar(50) comment '电子邮箱');
                          

索引列表：多个索引的定义项，相互之间用逗号隔开，可选。
什么是索引：索引就是数据库内部对某个表的所有数据行预先进行的某种排序。
          一个表可以设定（添加）多个索引，则就会有多个排序。
          就如新华字典，是“所有汉字”的一个纸质表，其默认是按拼音的排序，同时前面还有个部首表，此部首查表就是该新华字典所有汉字的一个“索引”。
          对我们程序员的应用来说，索引只是一个对某个表的“设定”，一两个单词而已，
          而在数据库内部，数据库管理系统会创建并维护一个跟当前表关联的“索引表”，该表数据已经按某种方式排好了序。
          给一个表建立索引的目的是加速数据的读取。但同时加重了数据库增删改命令的负担，因而需要权衡考虑是否需要给某个表的某个字段设定索引。
          有如下几种索引：
普通索引：没有特定其他作用，就只是建立索引。设定形式：index|key [索引名] (字段名1[，字段名2,...])。
唯一索引：设定某字段为唯一，且建立索引。设定形式： unique [key] [索引名] (字段名1[，字段名2,...])。
主键索引：设定某字段为主键，且建立索引。设定形式：primary key [索引名] (字段名1[，字段名2,...])。
          主键索引是唯一索引的特例，也是唯一索引的“加强”，主键索引本身就包含了“唯一性”，同时主键索引的字段不能为空值（null）。
          有时候需要用多个字段来确定主键，此时称为“联合主键”。
          联合主键的意思是多个（２个以上）的字段合在一起才算主键设定。
          比如某个学生管理系统中有个“成绩表”，记录了一个学生整个大学所有所学课程的考试成绩。
          则该表中至少要记录３项信息：学生ＩＤ，课程名称，成绩。
          且此时我们要查到一个成绩，必须确定学生ＩＤ和课程名，才可能确定该成绩。
          我们不能说该学生成绩是多少，也不能说某门课成绩是多少，而必须说某个学生的某门课成绩是多少。
          此时，学生ＩＤ和课程名称合起来才能确定一个有意义的数据，这这个字段就构成“主键”。如图所示：。
          如果没有主键，则可能会造成数据的冲突或歧义，比如：工资表，如果没有主键，同名时就无法区分谁的工资是多少。
          成绩表，如果没有主键，则可能出现某个人的某门课有多个成绩数据。
全文索引：设定某字段可进行全文查找。 设定形式： fulltext [index][索引名] (字段名1[，字段名2,...])。
create table lmjssjj_tab(id int auto_incremnet,
                          user_name varchar(20),
                          email varchar(50),
                          age int,/*没有索引*/
                          key(email),/*普通索引*/
                          primary key(id),/*主键索引*/
                          unique key(user_name)/*唯一索引*/
                          );



约束列表：多个约束的定义项，相互之间用逗号隔开，可选。
什么是约束？故名思义，约束就是对表中数据的某种限制。
            当然此限制是我们人为加上去的为了使我们的数据更具有“合理性”和“安全性”。
            数据的最基本约束是“数据类型”，比如保存工资的字段，就不应该存入字符串值（这一点来说，excel表格就做不到），
            此时设定其数据类型就解决了此问题。但我们这里说的约束，是在现有已经设定好数据类型基础上的进一步“要求”，
            比如，一个学校的学生学号，有一个要求就是“不能重号”，则我们可以给该字段设定“唯一性”约束它，这就是唯一约束。
            mysql有如下几项约束：
主键约束：设定形式：[constraint] primary key (字段名1[，字段名2,...])。含义同字段的同名属性。
唯一约束：设定形式：[constraint] unique [index] (字段名1[，字段名2,...])。含义同字段的同名属性。
外键约束：设定形式：[constraint] foreign key (字段名1[，字段名2,...]) references 表名(字段名1[，字段名2,...]）。
什么是外键？外键就是关系数据库的一个基本特征的实现，
          表明该字段的值是跟外部的某个表的某个字段的值“对应”的，或者也可以说来自于该外部的某个表的某个字段值。
          如果给一个设定了外键的字段插入一个值，而该值并没有在该外键所指定的外部表的对应字段中出现，
          则该值就会插入失败，这也就是数据库内部的“约束机制”（使我们的数据更“纯净”），参考：
非空约束：其实就是字段属性中的“not null”，只能在字段上设置。
默认约束：其实就是字段属性中的“default 默认值”，只能在字段上设置。
检查约束：指使用一定的判断表达式来对某个字段中的值进行“合理性”限制，
          比如年龄字段，虽可以设定为tinyint，但其实仍然会超出合理范围，则可以设定检查约束，只能输入0-120作为“合法年龄”数据。
          不过，当前mysql版本尚不支持。
create table lmjssjj_tab(id int auto_increment primary key,
                          classs varchar(10) unique key comment '班级号',
                          teacher varchar(10) comment '老师',
                          school_opens data comment '开学'
                          );
create table lmjssjj_tabl(stu_id int auto_increment primary key ,
                          name varchar(20),
                          banji_id int comment '班级id'
                          foreign key (binji_id) references lmjssjj_tab(id)
                           );
其实，主键约束，唯一约束，外键约束，只是“同一件事情的2个不同角度的说法”，他们同时也称为“主键索引”，“唯一索引”，“外键索引”。

表选项列表：多个表选项的设定项，相互之间用逗号或空格隔开，可选。常用表选项如下：
ENGINE=存储引擎名。
什么是存储引擎？存储引擎也叫“表类型”，是指一个表中的数据以何种方式存放在文件或内存中。
              不同的存储引擎（表类型）提供不同的性能特性和可用功能。没有一种各方面都又具有最佳性能又具有各种功能的存储引擎。
              我们要做的是要根据数据的具体使用情形（需求）来选择合适的存储引擎，
              有的要读取速度快，有的要写入速度快，有的要具有高安全可靠性，有的要海量存储，等等。
              常用的存储引擎是innoDB（默认）和Myisam。各种存储引擎性能与功能对比如下（了解）：
CHARACTER SET=要使用的编码名 [COLLATE=要使用的校对集名 ]
auto_increment = 自增长字段的起始值
comment='表的注释说明文字
create table lmjssjj(id int auto_increment primary key,
                      name varchar(20),
                      age tinyint
                     )
                     charset = gbk,  /*当前数据库的字符编码是utf8*/
                     engine = MyIsam,
                     auto_increment =1000,
                     comment ='文字说明';



修改表
修改表是指修改表的结构或特性。理论上创建一个表能做到的事情，修改表也能做到。
修改表有二三十项修改项，包括增删改字段，增删索引，增删约束，修改表选项等等。
举例如下：
添加字段：alter table 表名 add [column] 新字段名 字段类型 [字段属性列表]；
修改字段（并可改名）：alter table 表名 change [column] 旧字段名 新字段名 新字段类型 [新字段属性列表]；
修改字段（只改属性）：alter table 表名 modify [column] 　　　　　 字段名 新字段类型 [新字段属性列表]；
修改字段名：灰常灰常抱歉，没有单纯修改字段名这个功能！
删除字段：alter table 表名 drop [column] 字段名；
添加普通索引：alter table 表名 add index [索引名] (字段名1[，字段名2,...])；
添加主键索引(约束)：alter table 表名 add primary key (字段名1[，字段名2,...])；
添加外键索引(约束)：alter table 表名1 add foreign key (字段1，[，字段名2,...]) references 表名2(字段1，[，字段名2,...])；
添加唯一索引(约束)：alter table 表名 add unique (字段名1[，字段名2,...])；
添加字段默认值(约束)：alter table 表名 alter [column] 字段名 set default 默认值；
删除字段默认值(约束)：alter table 表名 alter [column] 字段名 drop default；
删除主键：alter table 表名 drop primay key；#每一个表最多只能有一个主键
删除外键：alter table 表名 drop foreign key 外键名；
删除索引：alter table 表名 drop index 索引名；
修改表名：alter table 表名 rename [to] 新表名；
修改表选项：alter table 表名 选项名1=选项值1，选项名2=选项值2，...；

删除表: drop table [if exists] 表名；

其他表相关语句：
显示所有表: show tables；
显示某表的结构: desc 表名； 或：describe 表名；
显示某表的创建语句：show create table 表名；
重命名表：rename table 旧表名 to 新表名；
从已有表复制表结构：create table [if not exists] 新表名 like 原表名;
创建索引：create [unique | fulltext] index 索引名 on 表名(字段名1[，字段名2,...])。这里省略unique或fulltext，那就是普通索引。
            实际上此创建索引语句，会在系统内部映射为一条“alter table”的添加索引语句。
删除索引：drop index 索引名 on 表名。实际上，此语句同样被映射为一条“alter table”的删除索引语句。




视图定义语句
什么是视图？视图是一个虚拟表，其内容由一条查询语句来定义。
           也可以认为，视图就是一条select语句的查询结果，只是预先放在数据库中而已。
           我们可以将此查询结果（有行有列有字段名）当作一个表来使用。
创建视图： create view 视图名 [（列名1，列名2，...）] as select语句；
create  view  v1  as 
select  id,  f1,  name,  age,  email,  p_id,  f3  from  表1  where id > 7 and  id < 100  or  f1 < 1000  and  age > 10

select * from v1 limit 0,10;
select id,p_id from v1;
select id from v1 where id<252 limit 0,10;

视图名不能跟表名同名——因为他们都是隶属于数据库的“对象”；
视图的默认列名就是定义视图的时候的select语句中设定的列名；
视图定义的时候也可以指定自己的列名，但此时指定的列名数应该跟select语句的列名数相等；
select语句可以从多个表中取用数据，甚至还可以从其他视图中取数据
修改视图： alter view 视图名 [（列名1，列名2，...）] as select语句；
删除视图： drop view [if exists] 视图名；

数据库（表）设计介绍：
所谓数据库的设计，通常就是指数据表的设计，也就是表结构的设计，以及需要哪些表。
这种设计基本都是由每一个具体的项目功能来决定的。
我们需要确定一个项目会用到哪些“现实数据”，以及为实现这些功能还需要创建（或定义）哪些数据才可以到达功能目标。
这也就是构成了一个项目的数据库设计工作。
数据库设计工作通常都是一个项目在技术层面最为重要和基础的工作。
数据库设计没定下来，后续的开发工作很难进行。
数据库设计得不好，后续的开发工作就可能问题重重。
数据库设计原则——也称为数据库设计三范式（3NF）
第一范式（1NF）：原子性，数据不可再分：一个表中的数据（字段值）不可再分。我们来看一个不良做法：范式1，再来看修正后的做法：范式1
第二范式（2NF）：唯一性，消除部分依赖：一个表中的每一行必须唯一可区分，且非主键字段值完全依赖主键字段值。也可说，必须消除在一个表中的的非主键字段值仅仅依赖于部分主键值的情形。显然这个要求只对有联合主键的表才有可能违反情况的，而对单字段主键的表是不会出现的。不良做法：范式2，修正之后：范式2
第三范式（3NF）：独立性，消除传递依赖：使一个表中的任何一个非主键，完全独立地依赖于主键，而不能又依赖于另外的非主键。如果一个表中的一个非主键字段（B）依赖于另一个非主键字段（A），因为A作为非主键字段，自然是依赖于主键字段的（范式2所决定），则此时就会出现传递依赖：（主键）->（A）->（B）。第三范式就是要消除（或避免）这种依赖。通常的实际做法中，我们只要注意做到“一个表存储一种数据”就可以符合第三范式。不良做法：范式3，修正之后：范式3

相关说明：
数据库设计范式是指导我们设计出没有或较少数据冗余并具有良好数据关系的理论而已。
但实际上第一范式我们无需考虑就可以显而易见地做到，而第二第三范式合在一起我们通常只要做到“一个表只存一种数据”就可以达到。
理论通常都难于理解，但实践通常都容易做到。
后一范式都是在满足前一范式的基础上再加强一点要求的结果。
在实际应用中，我们并不总是去绝对完全符合三范式来设计数据表。
有时候出于效率或其他因素的考虑，可能特意设计出略微不符合第二范式或第三范式的表，也是可以的。

