https://github.com/alibaba/ARouter

## 创建注解工程

```
定义注解
```



## 创建注解处理器（java工程）

​		注解处理器（Annotation Processor）是**javac**的一个工具，它用来在编译时扫描和处理注解（Annotation）。你可以对自定义注解，并注册相应的注解处理器。

​		例子：工厂模式、路由跳转(收集用户定义的某些对象，做一些有规则的代码)

```
添加依赖
implementation 'com.google.auto.service:auto-service:1.0-rc6'
```

```
通过解析注解生成代码（javapoet）
```

```java
//创建注解处理器类
/**
 * 指定使用的Java版本 替代 {@link 					AbstractProcessor#getSupportedSourceVersion()} 函数
 * 声明我们注解支持的JDK的版本
 */
@SupportedSourceVersion(SourceVersion.RELEASE_8)
/**
 * 注册给哪些注解的  替代 {@link AbstractProcessor#getSupportedAnnotationTypes()} 函数
 * 声明我们要处理哪一些注解 该方法返回字符串的集合表示该处理器用于处理哪些注解
 */
@SupportedAnnotationTypes({"com.google.auto.service.AutoService"})
@AutoService(Processor.class)
public class MyProcessor extends AbstractProcessor {
    /**
     * 文件生成器 类/资源
     * 生成java文件等
     */
    private Filer mFilerUtils;
    /**
     *gradle上定义的参数
     */
    private String moduleName;
    
 	@Override
    public synchronized void init(ProcessingEnvironment processingEnvironment) {
        super.init(processingEnvironment); 
        mFilerUtils = processingEnvironment.getFiler();
        //拿到gradle 定义的module名字
        Map<String, String> options = processingEnvironment.getOptions();
        if (!Utils.isEmpty(options)) {
            moduleName = options.get("moduleName");
        }
        
    }
    
    /**
     * 相当于main函数，正式处理注解
     * @param set 使用了支持处理注解  的节点集合
     * @param roundEnvironment 表示当前或是之前的运行环境,可以通过该对象查找找到的注解。
     * @return true 表示后续处理器不会再处理(已经处理)
     */
    @Override
    public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
    
        
        
    }
}
```

```
//定义module name 为注解处理器提供参数
android {
    defaultConfig {
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [ moduleName : project.getName() ]
            }
        }
    }
}
```

