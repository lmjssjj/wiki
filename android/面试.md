# Handler

```
	Handler 是标准的事件驱动模型，存在一个消息队列 MessageQueue，它是一个基于消息触发时间的优先级队列，还有一个基于此消息队列的事件循环 Looper，Looper 通过循环，不断的从 MessageQueue 中取出待处理的 Message，再交由对应的事件处理器 Handler/callback 来处理。
	其中 MessageQueue 被 Looper 管理，Looper 在构造时同步会创建 MessageQueue，并利用 ThreadLocal 这种 TLS，将其与当前线程绑定。而 App 的主线程在启动时，已经构造并准备好主线程的 Looper 对象，开发者只需要直接使用即可。Handler 类中封装了大部分「Handler 机制」对外的操作接口，可以通过它的 send/post 相关的方法，向消息队列 MessageQueue 中插入一条 Message。在 Looper 循环中，又会不断的从 MessageQueue 取出下一条待处理的 Message 进行处理。IdleHandler 使用相关的逻辑，就在 MessageQueue 取消息的 next() 方法中。

Handler的runWithScissors()被标记为 @hide(Android 4.2中新增)
线程通过 Handler 向Handler线程发送一个任务，并等Handler线程处理此任务后，再继续执行调的线程;（BlockingRunnable.postAndWait）

IdleHandler 
IdleHandler 说白了，就是 Handler 机制提供的一种，可以在 Looper 事件循环的过程中，当出现空闲的时候，允许我们执行任务的一种机制。

IdleHandler和activity的生命周期有关系 finishActivity的时候会 回调 onStop 和 onDestroy
在ActivityThread.handleResumeActivity()中 最后会调用
 // 主线程空闲时会执行 Idler
Looper.myQueue().addIdleHandler(new Idler());



```

# 内存泄露

```
	内存泄露的根本原因：长生命周期的对象持有短生命周期的对象。短周期对象就无法及时释放。
1. 静态集合类引起内存泄露
	主要是hashmap，Vector等，如果是静态集合 这些集合没有及时setnull的话，就会一直持有这些对象。
2.remove 方法无法删除set集 Objects.hash(firstName, lastName);
	经过测试，hashcode修改后，就没有办法remove了。
3.observer 我们在使用监听器的时候，往往是addxxxlistener，但是当我们不需要的时候，忘记removexxxlistener，就容易内存leak。
	广播没有unregisterrecevier
4.各种数据链接没有关闭，数据库contentprovider，io，sokect等。cursor

5.内部类：
	java中的内部类（匿名内部类），会持有宿主类的强引用this。
	所以如果是new Thread这种，后台线程的操作，当线程没有执行结束时，activity不会被回收。
	Context的引用，当TextView 等等都会持有上下文的引用。如果有static drawable，就会导致该内存无法释放。
6.单例
	单例 是一个全局的静态对象，当持有某个复制的类A是，A无法被释放，内存leak。
```

# 如何避免OOM

```
减少内存对象的占用
1.ArrayMap/SparseArray代替hashmap
	HashMap内部存储结构是使用哈希表的拉链结构（数组+链表）每一个结点都是Entry类型(Entry存储的内容有key、value、hash值)
	通过计算元素key的hash值，然后对HashMap中数组长度取余得到该元素存储的位置
	有多个元素key的hash值相同的话，后一个元素并不会覆盖上一个元素，而是采取链表的方式，把之后加进来的元素加入链表末尾，从而解决了		hash冲突的问题，由此我们知道HashMap中处理hash冲突的方法是链地址法，在此补充一个知识点，处理hash冲突的方法有以下几种：
		开放地址法
		再哈希法
		链地址法
		建立公共溢出区
	HashMap中默认的存储大小就是一个容量为16的数组，所以当我们创建出一个HashMap对象时，即使里面没有任何元素，也要分别一块内存空间给它，而且，我们再不断的向HashMap里put数据时，当达到一定的容量限制时（这个容量满足这样的一个关系时候将会扩容：HashMap中的数据量>容量*加载因子，而HashMap中默认的加载因子是0.75），HashMap的空间将会扩大，而且扩大后新的空间一定是原来的2倍,只要一满足扩容条件，HashMap的空间将会以2倍的规律进行增大。假如我们有几十万、几百万条数据，那么HashMap要存储完这些数据将要不断的扩容，而且在此过程中也需要不断的做hash运算，这将对我们的内存空间造成很大消耗和浪费，而且HashMap获取数据是通过遍历Entry[]数组来得到对应的元素，在数据量很大时候会比较慢，所以在Android中，HashMap是比较费内存的，我们在一些情况下可以使用SparseArray和ArrayMap来代替HashMap。
	
SparseArray
	SparseArray比HashMap更省内存，在某些条件下性能更好，主要是因为它避免了对key的自动装箱（int转为Integer类型），它内部则是通过两个数组来进行数据存储的，一个存储key，另外一个存储value，为了优化性能，它内部对数据还采取了压缩的方式来表示稀疏数组的数据，从而节约内存空间，我们从源码中可以看到key和value分别是用数组表示：
	    private int[] mKeys;
   		private Object[] mValues;
   	SparseArray只能存储key为int类型的数据，同时，SparseArray在存储和读取数据时候，使用的是二分查找法,put添加数据的时候，会使用二分查找法和之前的key比较当前我们添加的元素的key的大小，然后按照从小到大的顺序排列好，所以,SparseArray存储的元素都是按元素的key值从小到大排列好的。而在获取数据的时候，也是使用二分查找法判断元素的位置，所以，在获取数据的时候非常快，比HashMap快的多，因为HashMap获取数据是通过遍历Entry[]数组来得到对应的元素。
   	SparseArray应用场景：
虽说SparseArray性能比较好，但是由于其添加、查找、删除数据都需要先进行一次二分查找，所以在数据量大的情况下性能并不明显，将降低至少50%。
	满足下面两个条件我们可以使用SparseArray代替HashMap：
		数据量不大，最好在千级以内
		key必须为int类型，这中情况下的HashMap可以用SparseArray代替
	
ArrayMap
	ArrayMap是一个<key,value>映射的数据结构，它设计上更多的是考虑内存的优化，内部是使用两个数组进行数据存储，一个数组记录key的hash值，另外一个数组记录Value值，它和SparseArray一样，也会对key使用二分法进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找法得到相应的index，然后通过index来进行添加、查找、删除等操作，所以，应用场景和SparseArray的一样，如果在数据量比较大的情况下，那么它的性能将退化至少50%。

总结
SparseArray和ArrayMap都差不多，使用哪个呢？
	假设数据量都在千级以内的情况下：
	1、如果key的类型已经确定为int类型，那么使用SparseArray，因为它避免了自动装箱的过程，如果key为long类型，它还提供了一个LongSparseArray来确保key为long类型时的使用
	2、如果key类型为其它的类型，则使用ArrayMap
	

2.避免在android里面使用Enum
	实际上 enum 就是一个 class 
	编译器会帮我们生成多个枚举类的实例，赋值给我们定义的枚举类型常量，并且还声明了一个枚举对象的数组，保存了所有的枚举对象。
3.减少bitmap的内存占用
	inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。
	decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。
4.减少资源图片的大小，过大的图片可以考虑分段加载

内存对象的重复利用
大多数对象的复用，都是利用对象池的技术。
	
	1.listview/gridview/recycleview contentview的复用
	2.inBitmap 属性对于内存对象的复用ARGB_8888/RBG_565/ARGB_4444/ALPHA_8
	这个方法在某些条件下非常有用，比如要加载上千张图片的时候。
	3.避免在ondraw方法里面 new对象
	4.StringBuilder 代替+
```

# Android 中如何捕获未捕获的异常

```
CrashHandler
关键是实现Thread.UncaughtExceptionHandler
然后是在application的oncreate里面注册。
```

# Android 程序运行时权限与文件系统权限的区别

```
文件的系统权限是由linux系统规定的，只读，读写等。

运行时权限，是对于某个系统上的app的访问权限，允许，拒绝，询问。该功能可以防止非法的程序访问敏感的信息。
```

#  Activity 进入和退出动画

```
overridePendingTransition
必需紧挨着startActivity()或者finish()函数之后调用
```

